- ## 使用示例
  ```
  var req = UserPublic.LoginReq.newBuilder().setEmail(email).setPassword(password).build()
  val method = UserGrpc.newBlockingStub(MockConfig.channel)::login
  asyncTask(req, method) {
      showUserInfo(it)
  }
  ```
## 实现机制：泛型方法+高阶函数
```
fun <Req, Resp> asyncTask(req: Req, function: (Req) -> Resp?, errorHandler: (Throwable) -> Any = SystemConfig.defaultErrorHandler, consumer: (Resp?) -> Any) {
    val errorHandler = CoroutineExceptionHandler { _, exception ->
        errorHandler.invoke(exception)
    }
    launch(errorHandler) {
        var resp = async(Dispatchers.IO) {
            function.invoke(req)
        }.await()
        consumer.invoke(resp)
    }
}
```

它有默认的错误处理，也可以自定义错误处理，默认的话，只是打印一下错误，可以自己重写errorHandler参数
```
class SystemConfig {
    companion object {
        val defaultErrorHandler: (Throwable) -> Any = { exception ->
            {
                LogUtils.print("Caught $exception")
            }
        }
    }
}
```
## 优点
1. 将业务代码和模板代码分离，就算以后不用协程了，也可以很方便的切换成其它线程调度框架
2. 方便后期拓展，现在的模板代码只是做了线程切换，以后可以加上加载进度条的显示和隐藏等等"