- [[TODO]]
- java内存模型
- 线程私有
- 程序计数器
- 虚拟机栈
- 局部变量表
- 操作数栈
- 本地方法栈
- 所有线程共享
- metaspace
- 元空间和永久代
- 堆
- 常量池
- 常见面试题
- 三大性能调优参数
- -xss  -xms -xss
- 堆和栈的区别
- 不同版本之间的intern()方法的区别
- 其它
- 地址空间的划分
- 分段
- 分页
- StackOverFlowError
- OutOfMemoryError
- intern()
- == 比较地址
- 为什么会出现金三银四的现象？
- 金三银四是找工作的最佳时期吗？
- 相对容易找到工作的时期
- 临近年末的时候
- 年末跳槽的好与坏
- 谈薪方式
- 直接和猎头表达
- 说出顾虑
- Java垃圾回收机制
- 判定对象是否为垃圾的标准
- 判定对象的引用数量
- 循环引用问题
- 判定对象的引用链是否可达
- GC Root
- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中的常量引用的对象
- 方法区中的类静态属性引用的对象
- 本地方法栈中JNI（native方法）的引用对象
- 活跃线程的引用对象
- 谈谈你了解的垃圾回收算法
- 标记清楚算法
- 碎片化问题
- 复制算法
- 适用于年轻代
- 空间浪费问题
- 标记整理算法
- 适用于老年代
- 分代收集算法
- 年轻代
- Minor GC
- Eden区
- 两个Survivor区
- 老年代
- Full GC
- 对象如何晋升老年代
- 经历一定Minor次数依然存活的对象
- Survivor中存放不下的对象
- 新生成的大对象 -XX:+PretenuerSizeThreshold
- 常用的调优参数
- -XX:SurvivorRatio Eden和Survivor的比值，默认8：1
- -XX:NewTatio 老年代和年轻代内存大小的比例
- -XX:MaxTenuringThreshold 对象从年轻代晋升到老年代经历GC次数的最大阈值
- Full GC 和 Major GC
- [触发Full GC的条件](%E8%A7%A6%E5%8F%91Full%20GC%E7%9A%84%E6%9D%A1%E4%BB%B6/%E8%A7%A6%E5%8F%91Full%20GC%E7%9A%84%E6%9D%A1%E4%BB%B6.md)
- Stop-the-world
- Safepoint
- 分析过程中对象引用关系不会变化的点
- 产生Safepoint的地方：方法调用、循环跳转、异常跳转等
- 安全点数量适中
- 常见的垃圾收集器
- JVM的运行模式
- Server
- Client
- 垃圾收集器之间的关系
- 年轻代
- Serial
- -XX:+UseSerialGC 复制算法
- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的年轻代收集器
- ParNew
- -XX:+UseParNewGC 复制算法
- 多线程收集，其余的行为、特点和Serial收集器一样
- 单核执行效率不如Serial，在多核下执行才有优势
- Parallel Scavenge
- -XX:+UseParallelGC 复制算法
- 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
- 比起关注用户线程停顿时间，更关注系统的吞吐量
- 在多核下执行才有优势，Server模式下默认的年轻代收集器
- -XX:+UseAdaptiveSizePolicy
- 老年代
- CMS
- -XX:UseConcMarkSweepGC 标记清楚算法
- *初始标记 stop-the-world
- 并发标记：并发追溯标记，程序不会停顿
- 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
- *重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
- 并发清理：清理垃圾对象，程序不会停顿
- 并发重置：重置CMS收集器的数据结构
- Serial Old (MSC)
- -XX:+UseSerialOldGC 标记整理算法
- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模型下默认的老年代收集器
- Parallel Old
- -XX:+UseParallelOldGC 标记整理算法
- 多线程，吞吐量优先
- G1
- -XX:UseG1GC 复制-标记-整理算法
- 特点
- 并行和并发
- 分代收集
- 空间整合
- 可预测的停顿
- 将整个Java堆内存分成多个大小相等的Region
- 年轻代和老年代不再物理隔离
- Object的finalize()方法的作用是否与C++的析构函数作用相同
- 与C++的析构函数不同，析构函数调用确定，而它是不确定的
- 将未引用的对象放置于F-Queue队列
- 方法执行随时可能被终止
- 给与对象最后一次重生的机会
- Java中的强引用、软引用、弱引用、虚引用有什么用
- 强引用 Strong Reference
- 最普遍的引用：Object obj=new Object()
- 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
- 通过将对象设置为null来弱化引用，使其被回收
- 软引用 Soft Reference
- 对象处在有用但非必须的状态
- 只有当内存空间不足时，GC会回收该引用的对象的内存
- 可以用来实现高速缓存
- SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str)
- 弱引用 WeakReference
- 非必须的对象，比软引用更弱一点
- GC时会被回收
- 被回收的概率也不大，因为GC的线程优先级比较低
- 适用于引用偶尔被使用且不影响垃圾收集的对象
- WeakReference&lt;String&gt; weakRef=new WeakReference&lt;String&gt;(str)
- 虚引用 PhantomReference
- 不会决定对象的生命周期
- 任何时候都可能被垃圾回收器回收
- 跟踪对象被垃圾回收器回收的活动，起哨兵作用
- 必须和引用队列ReferenceQueue联合使用
- 用例
- ReferenceQueue queue=new ReferenceQueue()
- PhantomReference ref=new PhantomReference(str，queue)
- 引用队列 ReferenceQueue
- 无实际存储结构，存储结构依赖于内部节点之间的关系来表达
- 存储关联的且被GC的软引用、弱引用以及虚引用
- 招聘相关
- 同事朋友内推
- 最有推荐的一种
- 简历直达团队，避免被非团队的人员筛掉
- 知己知彼
- 避免简历被锁
- 注意：碍于情面，错过后面的好公司
- 招聘网站的投递
- 简历会被锁定
- 太多的虚假信息
- 猎头招聘
- 人性最真实的一面
- 猎头对特定的公司、职位比较熟悉
- 找多个猎头，多方面了解市场
- 做好恶战的准备
- 搭线练手公司，查漏补缺
- 找工作的渠道总结
- 利用猎头对公司进行分类：练手公司和心仪公司
- 竭尽全力挖掘目标公司的内部员工
- 关于JDK版本的选择
- 选择JDK8和JDK11进行讲解的原因：Oracle长期支持
- Java线程知识考点
- 进程和线程的由来
- 进程和线程的区别
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 所有与进程相关的资源，都被记录在PCB中
- 进程是抢占处理机的调度单位，线程属于某个进程，共享其资源
- 线程只有堆栈寄存器、程序计数器和TCB组成
- 总结
- 线程不能看成独立应用，而进程可看做独立应用
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
- 线程没有独立的地址空间，多进程的程序比多线程程序健壮
- 进程的切换比线程的切换开销大
- Java进程和线程的关系
- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个程序会产生一个进程，进程包含至少一个线程
- 每个线程对应一个JVM实例，多个线程共享JVM里的堆
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上要后于子线程完成执行
- JVM默认有几个线程
- Thread的run方法和start方法的区别
- 调用start方法会创建一个新的子线程并启动并执行run方法
- 直接调用run方法，只是Thread的一个普通方法的调用
- Thread和Runnable是什么关系
- Thread是实现了Runnable接口的类，使得run支持多线程
- 因为类的单一继承原则，推荐多使用Runnable接口
- 如何给run方法传参
- 实现的方式主要有三种
- 构造函数传参
- 成员变量传参
- 回调函数传参
- 如何实现处理线程的返回值
- 实现的方式主要有三种
- 主线程等待法
- 使用Thread类的join()阻塞当前线程以等待子线程处理完毕
- 通过Callable接口实现：通过FutureTask or 线程池获取
- 线程的状态
- 六个状态
- 新建 new
- 创建后尚未启动的线程的状态
- 运行 runnable
- 包含running 和 ready
- 无限期等待 waiting
- 不会被分配CPU执行时间，需要显式被唤醒
- 没有设置Timeout参数的Object.wait()方法
- 没有设置Timeout参数的Thread.join()方法
- LockSupport.park()方法
- 限期等待 timed waiting
- 在一定时间后会被系统自动唤醒
- Thread.sleep()方法
- 设置了Timeout参数的Object.wait()方法
- 设置了Timeout参数的Thread.join()方法
- LockSupport.parkNanos()方法
- LockSupport.parkUntil()方法
- 阻塞 blocked
- 等待获取排他锁
- 结束 Terminated
- 已终止线程的状态，线程已经结束执行
- sleep和wait的区别
- 基本的差别
- sleep是Thread类的方法，wait是Object类中定义的方法
- sleep方法可以在任何地方使用
- wait方法只能在synchronized方法或synchronized块中使用
- 最主要的区别
- Thread.sleep只会让出CPU，不会导致锁行为的改变
- Object.wait不仅让出CPU，还会释放已经占有的同步资源锁
- notify和notifyAll的区别
- 锁池
- 等待池
- notifyAll 会让所有处于等待池中的线程全部进入锁池去竞争获取锁的机会
- notify 只会随机选取一个处理等待池中的线程进入锁池去竞争获取锁的机会
- yield
- 概念
- 当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示
- 如何中断线程
- 通过调用stop()方法停止线程，已经被抛弃的方法
- 通过调用suspend()和resume()方法，已经被抛弃的方法
- 通过interrupt()，通知线程应该中断了
- 1. 如果线程处理被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptException异常
- 2. 如果线程处理正常活动状态，那么会将该线程的中断标志设置为true，被设置中断标志的线程将继续正常运行，不受影响
- 目前使用的方法
- 需要被调用的线程配合中断
- 1. 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程
- 2. 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，被设置中断标志的线程将继续正常运行，不受影响
- 线程状态以及状态之间的转换
- 如何有效地让薪资更上一层楼
- 增加自己的筹码
- 尽量打听公司岗位职位的薪酬幅度
- 感知目标公司的缺人程度，工作的紧急程度
- 最有效的方式是已经具备了有竞争力的offer
- synchronized
- 线程安全问题的主要诱因
- 存在共享数据
- 原子性
- 可见性
- synchronize锁的不是代码，是对象
- 根据获取锁的分类：获取对象锁和获取类锁
- 获取对象锁的两种用法
- 1. 同步代码块 synchronize(this) synchroniezd(类实例对象) 锁是小括号()中实例对象
- 2. 同步非静态方法 synchronize method，锁是当前对象的实例对象
- 获取类锁的两种方法
- 1. 同步代码块 synchronize(类.class) 锁是小括号()中的类对象(Class对象)
- 2. 同步静态方法 synchronize static method，锁是当前对象的类对象(Class对象)
- synchronized底层实现原理
- Monitor 每个Java对象天生自带了一把看不见的锁
- Monitor 锁的竞争、获取与释放
- 什么是重入
- 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处理阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入
- 为什么会对synchronized嗤之以鼻
- 早期版本中，synchronized 属于重量级锁，依赖于Mutex Lock实现
- 线程之间的切换需要从用户态切换到核心态，开销较大
- Java6以后，synchronized 性能得到了很大的提升
- Adaptive Spinning
- Lock Eliminate
- Lock Coarsening
- Lightweight Locking
- Biased Locking
- 自旋锁与自适应锁
- 自旋锁
- 许多情况下，共享数据的锁定状态持续状态较短，切换线程不值得
- 通过让线程执行忙循环等待锁的释放，不让出CPU
- 缺点
- 若锁被其它线程长时间占用，会带来许多性能上的开销
- PreBlockSpin
- 自适应自旋锁
- 自旋的次数不再固定
- 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
- 锁消除
- 更彻底的优化
- JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁
- 锁粗化
- 另一种极端
- 通过扩大加锁的范围，避免反复加锁和解锁
- synchronized的四种状态
- 无锁
- 偏向锁
- 减少同一线程获取锁的代价
- 大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得
- 核心思想
- 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark World 的结构也变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word 的锁标记位为偏向锁以及当前线程Id等于Mark Word的Thread ID即可，这样就省去了大量有关锁申请的操作
- 轻量级锁
- 轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁
- 适应的场景
- 线程交替执行同步块
- 若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁
- 重量级锁
- 锁膨胀方向，如上
- 锁的内存语义
- 当线程释放锁时，Java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中
- 而当线程获取锁时，Java内存模型会把该线程对应的本地内存设置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量
- CAS compare and swap
- synchronized和ReentrantLock的区别
- ReentrantLock 再入锁
- 位于java.util.concurrent.locks包
- 和CountDownLatch、FutureTask、Semaphore一样基于AQS实现
- 能够实现比synchronized更细粒度的控制，如控制fairness
- 调用lock()之后，必须调用unLock()释放锁
- 性能未必比synchronized高，并且也是可重入的
- ReentrantLock公平性的设置
- ReentrantLock fairLock=new ReentrantLock(true)
- 参数为true时，倾向于将锁赋予等待时间最久的线程
- 公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）
- 非公平锁：抢占的顺序不一定，看运气
- synchronized是非公平锁
- ReentrantLock将锁对象化
- 判断是否有线程，或者某个特定线程，在排队等待获取锁
- 带超时的获取锁的尝试
- 感知有没有成功获取锁
- 是否能将wait/notify/notifyAll对象化
- ArrayBlockingQueue
- 总结
- synchronized是关键字，ReentrantLock是类
- ReentrantLock可以对获取锁的等待时间进行设置，避免死锁
- ReentrantLock可以获取各种锁的信息
- ReentrantLock可以灵活地实现多路通知
- 机制：synchronized操作Mark Word , lock调用Unsafe类的park()方法
- 什么是Java内存模型中的happens-before
- Java内存模型JMM
- Java内存模型（即 Java Memory Model，简称JMM），本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式
- JMM中的主内存
- 存储Java实例对象
- 包括成员变量、类信息、常量、静态变量等
- 属于数据共享的区域，多线程并发操作时会引发线程安全问题
- JMM中的工作内存
- 存储当前方法的所有本地变量信息，本地变量对其它线程不可见
- 字节码行号指示器、native方法信息
- 属于线程私有数据区域，不存在线程安全问题
- JMM与Java内存区域划分是不同的概念层次
- JMM描述的是一组规则，围绕原子性、有序性、可见性展开
- 相似点：存在共享区域和私有区域
- 主内存与工作内存的数据存储类型以及操作方式归纳
- 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中
- 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中
- 成员变量、static变量、类信息均会被存储在主内存中
- 主内存共享的方式是线程各拷贝一份数据到工资内存，操作完成后刷新回主内存
- JMM如何解决可见性问题
- 指令重排序需要满足的条件
- 在单线程环境下不能改变程序运行的结果
- 存在数据依赖关系的不允许重排序
- 无法通过happens-before原则推导出来的，才能进行指令的重排序
- A操作的结果需要对B操作可见，则A与B存在happens-before关系
- happens-before的八大原则
- 1. 程序次序规则
- 一个线程内，按照代码顺序，书写在前面