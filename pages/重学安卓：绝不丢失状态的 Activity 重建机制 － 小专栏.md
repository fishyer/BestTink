- [重学安卓：绝不丢失状态的 Activity 重建机制 － 小专栏](https://xiaozhuanlan.com/topic/7692814530)
- "
- 状态保存和恢复的具体过程？（99% 的网文遗漏的关键细节）
- App 切到后台，页面临时数据 “防丢” 的妙招
- 然而却没有一篇深入地探究过：当走 Save 和 Restore 时，过程中究竟经历了哪些细节、背后 决定状态被成功保存和恢复的关键条件 到底是怎样的。
- 通常是 “系统资源的回收” 或 “配置发生变化” 导致的重建。
- 例如按下 Home 键切回桌面，或是接电话跳转到电话程序，都有可能使此前的这个 App 处于背景模式。
- 当系统配置发生变化时，比如屏幕方向（旋转屏幕）、屏幕大小（折叠屏）、语言的改变等。
- 一来：对于资源回收的情况，保存状态并等到使用时再恢复，要比后台存留进程 所占的资源要小得多。
- 二来：对于配置变化的情况，比如当屏幕方向发生变化时，唯有重建，才有机会加载不同的界面，特别如果 横屏、竖屏、折叠屏 的布局不同的话。
- 自 API 28 起（CompileSDKVersion、TargetSDKVersion >= 28 并且 Android 系统版本 >= 9.0 的环境下），onSaveInstanceState 执行时机已确定为在 onStop 之后。具体可见读者 Flywith24 在 评论区 11 楼 的补充。
- 一个是 View 的 States，专门用于存储 View 的状态；
- 再一个是 Instance 的 States，用于存储 View 的 States 以及 开发者在 Save 中手动保存的 Activity 成员变量。
- Activity 在 Save 时，会 自动收集 View Hierachy 中每一个 “实现了状态保存和恢复方法” 的 View 的状态，这些状态数据会在 Restore 时回传给每一个 View。并且回传时是依据 View 的 id 来逐一匹配的。
- 1.为了成功保存状态，要求在 View 内部实现状态保存和恢复方法。
- 2.为了成功恢复状态，要求在布局中给 View 赋予相应的 id。
- 3.如果是 Activity 的成员变量，需要额外在 Activity（子类）中重写 Save 和 Restore 方法。
- 重写仅仅是为了额外地保存成员变量。重写方法时，记得要保留基类（super）的实现，Activity 正是在基类中完成 View 状态的保存和恢复。
- 在清单文件中为该 Activity 配置 android:configChanges 属性。 比如属性值 orientation|screenSize 对应着旋转屏幕，locale 对应着语言变化。
- 现在你只需 “将成员托管给 Jetpack ViewModel” 这一步就可以享受 “可暂存和恢复的成员”，具体可自行查阅《重学安卓 Jetpack ViewModel》篇的解析。
- Jetpack ViewModel 仅仅是使 “状态保存和恢复” 更简便和不易出错，但如果某些场景临时数据的恢复十分重要，那么可以考虑持久化存储，
- 此处的策略是改为 “间歇性提前自动将临时数据从内存 RAM 中备份到硬盘 ROM 中”，
- 在等待期间，它一直处于内存当中，默认状况下不会被回收，除非某些 Activity 设置了 flag（详见《任务和返回栈》篇），让任务中的其他 Activity 被出栈和清理。（对于这种情况，被清理的 Activity 是得不到恢复的，是直接被清理走了，与被系统回收的概念和目标物 皆不同。系统回收的目的是为了回收一些优先级不高的进程，来释放资源）
- 重建的概念只存在于视图控制器中，本文中介绍到，关于“为何存在重建的设计”。
- 首先，这篇文章是写给新手看的，经过我的调研，80% 的新手在遇到这种情况时，第一个想到的就是通过 数据的持久化存储。持久化未必就是专指 SQLite，像 SharePreference 这种都算。 再者，本文讨论的是 视图控制器 状态的存储和恢复，onSaveInstanceState 和onRestoreInstanceState 绝不仅仅是保存和恢复 View 的状态，也包括开发者手动保存和恢复的 视图控制器成员变量。 最后，状态管理的最佳实践是，通过 ViewModel 来托管状态。具体可参考 ViewModel 一章。
- 不保留活动->textview.settext->切换应用
- 你这里提到的 开发者选项设置的 不保留活动，不在状态重建的考虑范围。
- TODO 2020 年起，fragment 就算 replace，返回后仍然能恢复之前的状态，
- 具体可通过 重学安卓 配套项目 OneTestFragment 类 已搭建好的实验环境验证。
- 关于 onSaveInstanceState 的调用时机，android P 后发生了变化
- 事实上，这个项目的设计和维护 投入了我个人几乎所有空余的精力：为了方便开发者们无痛理解每个架构组件的 存在缘由、职责边界，项目中精心设计了高频的应用场景，且代码中 就各种 “为什么” 提供了丰富的注释。
- 这个问题通过对《重学安卓》配套项目“改吧改吧”就能快速验证自己的猜想了。
- 那么onCreate和onRestoreInstanceState都会有保存的数据,我们在实际开发中,应该选用哪个方法来恢复我们保存的自定义数据呢
- 在android P之后onSaveInstanceState 的调用时机在onStop之后，所以我觉得在后台做一些重量级操作应该没问题，但是在之前的版本，调用时机在onPause之前或之后不能确定，那么如果在onSaveInstanceState 不开子线程就做一些重量级操作还是会导致卡顿的吧
- 补充，不同的方式、不同的时机、不同的线程，去分治。
- onSavedInstanceState 仅用于 “页面重建” 场景的临时状态恢复，如果你已退出当前页面并再次打开，这是不符合使用场景的，也就不会再获取到上一次存储的临时状态。
- 对于第二个问题，如涉及持久化存储的场景需求，可通过改善持久化策略 来规避数据丢失的风险，具体可参见《生命周期》篇（上一篇）的文末加餐。
- 这个设计的是 android 自身的进程通信机制，由 bundle 包装，最终透过 binder 传输，那么 saveInstanceState 传输内容大小一般由 binder 的上限决定， 通常视图状态的保存耗费不了太多，而且当前我们尽量将状态（尤其是 List 等重量级数据）都托管给 ViewModel
- " https://diigo.com/0nqgui