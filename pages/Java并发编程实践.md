- 1-简介
	- 1-并发简史
	- 2-线程的优势
		- 1-发挥多处理器的强大能力
		- 2-建模的简单些
		- 3-异步事件的简化处理
		- 4-响应更灵敏的用户界面
	- 3-线程带来的风险
		- 1-安全性问题
		- 2-活跃性问题
		- 3-性能问题
	- 4-线程无处不在
- 1-基础知识
	- 2-线程安全性
		- 1-什么是线程安全性
		- 2-原子性
			- 1-竞态条件
			- 2-示例：延迟初始化中的竞态条件
			- 3-复合操作
		- 3-加锁机制
			- 1-内置锁
			- 2-重入
		- 4-用锁来保护状态
		- 5-活跃性与性能
	- 3-对象的共享
		- 1-可见性
			- 1-失效数据
			- 2-非原子的64位操作
			- 3-加锁与可见性
			- 4-Volatile变量
		- 2-发布与逸出
		- 3-线程封闭
			- 1-Ad-hoc线程封闭
			- 2-栈封闭
			- 3-ThreadLocal类
		- 4-不变性
			- 1-Final域
			- 2-示例：使用Volatile类型来发布不可变对象
		- 5-安全发布
			- 1-不正确的发布：正确的对象被破坏
			- 2-不可变对象与初始化安全性
			- 3-安全发布的常用模式
			- 4-事实不可变对象
			- 5-可变对象
			- 6-安全的共享对象
	- 4-对象的组合
		- 1-设计线程安全的类
			- 1-收集同步需求
			- 2-依赖状态的操作
			- 3-状态的所有权
		- 2-实例封闭
			- 1-Java监视器模式
			- 2-示例：车辆追踪
		- 3-线程安全性的委托
			- 1-示例：基于委托的车辆追踪器
			- 2-独立的状态变量
			- 3-当委托失效时
			- 4-发布底层的状态变量
			- 5-示例：发布准头盖的车辆追踪器
		- 4-在现有的线程安全类中添加功能
			- 1-客户端加锁机制
			- 2-组合
		- 5-将同步策略文档化
	- 5-基础构建模块
		- 1-同步容器类
			- 1-同步容器类的问题
			- 2-迭代器与ConcurrentModificationException
			- 3-隐藏迭代器
		- 2-并发容器
			- 1-ConcurrentHashMap
			- 2-额外的原子Map操作
			- 3-CpoyOnWriteArrayList
		- 3-阻塞队列和生产者-消费者模式
			- 1-示例：桌面搜索
			- 2-串行线程封闭
			- 3-双端队列与工作密取
		- 4-阻塞方法与中断方法
		- 5-同步工具类
			- 1-闭锁
			- 2-FutureTask
			- 3-信号量
			- 4-栅栏
		- 6-构建高效且可伸缩的结果缓存
- 2-结构化并发应用程序
	- 6-任务执行
		- 1-在线程中执行任务
			- 1-串行地执行任务
			- 2-显式地位任务创建线程
			- 3-无限制创建线程的不足
		- 2-Executor框架
			- 1-示例：基于Executor的Web服务器
			- 2-执行策略
			- 3-线程池
			- 4-Executor的生命周期
			- 5-延迟任务与周期任务
		- 3-找出可利用的并行性
			- 1-示例：串行的页面渲染器
			- 2-携带结果的任务Callable与Future
			- 3-示例：使用Future实现页面渲染器
			- 4-在异构任务并行化中存在的局限
			- 5-CompletionService：Executor与BlockingQueue
			- 6-示例：使用CompletionService实现页面渲染器
			- 7-为任务设置时限
			- 8-示例：旅行预订门户网站
	- 7-取消与关闭
		- 1-任务取消
			- 1-中断
			- 2-中断策略
			- 3-响应中断
			- 4-示例：计时运行
			- 5-通过Future来实现取消
			- 6-处理不可中断的阻塞
			- 7-采用newTaskFor来封装非标准的取消
		- 2-停止基于线程的服务
			- 1-示例：日志服务
			- 2-关闭ExecutorService
			- 3-“毒丸”对象
			- 4-示例：只执行一次的服务
			- 5-shutdownNow的局限性
		- 3-处理非正常的线程终止
		- 4-JVM关闭
			- 1-关闭钩子
			- 2-守护线程
			- 3-终结器
	- 8-线程池的使用
		- 1-在任务与执行策略之间的隐形耦合
			- 1-线程饿死死锁
			- 2-运行时间较长的任务
		- 2-设置线程池的大小
		- 3-配置ThreadPoolExecutor
			- 1-线程的创建与销毁
			- 2-管理队列任务
			- 3-饱和策略
			- 4-线程工厂
			- 5-在调用构造函数后再定制ThreadPoolExecutor
			- 6-拓展ThreadPoolExecutor
			- 7-递归算法并行化
	- 9-图形用户界面应用程序
		- 1-为什么GUI是单线程的
			- 1-串行任务处理
			- 2-Swing中的线程封闭机制
		- 2-短时间的GUI任务
		- 3-长时间的GUI任务
			- 1-取消
			- 2-进度标识和完成标识
			- 3-SwingWorker
		- 4-共享数据模型
			- 1-线程安全的数据模型
			- 2-分解数据模型
		- 5-其它形式的单线程子系统
- 3-活跃性、性能与测试
	- 10-避免活跃性危险
		- 1-死锁
			- 1-锁顺序死锁
			- 2-动态的锁顺序死锁
			- 3-在协作对象之间发生的死锁
			- 4-开放调用
			- 5-资源死锁
		- 2-死锁的避免与诊断
			- 1-支持定时的锁
			- 2-通过线程转储信息来分析死锁
		- 3-其它活跃性危险
			- 1-饥饿
			- 2-糟糕的响应性
			- 3-活锁
	- 11-性能与可伸缩性
		- 1-对性能的思考
			- 1-性能与可伸缩性
			- 2-评估各种性能权衡因素
		- 2-Amdahl定律
			- 1-示例：在各种框架中隐藏的串行部分
			- 2-Amdahl定律的应用
		- 3-线程引入的开销
			- 1-上下文切换
			- 2-内存同步
			- 3-阻塞
		- 4-减少锁的竞争
			- 1-缩小锁的范围（“快进快出”）
			- 2-减小锁的粒度
			- 3-锁分段
			- 4-避免热点域
			- 5-一些替代独占锁的方法
			- 6-监测CPU的利用率
			- 7-向对象池说“不”
		- 5-示例：比较Map的性能
		- 6-减少上下文切换的开销
	- 12-并发程序的测试
		- 1-正确性测试
			- 1-基本的单元测试
			- 2-对阻塞操作的测试
			- 3-安全性测试
			- 4-资源管理的测试
			- 5-使用回调
			- 6-产生更多的交替操作
		- 2-性能测试
			- 1-在PutTaskTest中增加计时功能
			- 2-多种算法的比较
			- 3-响应性衡量
		- 3-避免性能测试的陷阱
			- 1-垃圾回收
			- 2-动态编译
			- 3-对代码路径的不真实采样
			- 4-不真实的竞争程度
			- 5-无用代码的消除
		- 4-其他的测试方法
			- 1-代码审查
			- 2-静态分析工具
			- 3-面向方面的测试技术
			- 4-分析与监测工具
- 4-高级主题
	- 13-显式锁
		- 1-Lock与ReentrantLock
			- 1-轮询锁与定时锁
			- 2-可中断的锁获取操作
			- 3-非块结构的加锁
		- 2-性能考虑因素
		- 3-公平性
		- 4-在synchronized与ReentrantLock之间进行选择
		- 5-读-写锁
	- 14-构建自定义的同步工具
		- 1-状态依赖性的管理
			- 1-示例：将前提条件的失败传递给调用者
			- 2-示例：通过轮询与休眠来实现简单的阻塞
			- 3-条件队列
		- 2-使用条件队列
			- 1-条件谓词
			- 2-过早唤醒
			- 3-丢失的信号
			- 4-通知
			- 5-示例：阀门类
			- 6-子类的安全问题
			- 7-封装条件队列
			- 8-入口协议与出口协议
		- 3-显式的Condition对象
		- 4-Synchronizer剖析
		- 5-AbstractQueueSynchronizer
		- 6-java.util.concurrent同步容器类中的AQS
			- 1-Reentrantlock
			- 2-Semaphore与CountDownLatch
			- 3-FutureTask
			- 4-ReentrantReadWriteLock
	- 15-原子变量与非阻塞同步机制
		- 1-锁的劣势
		- 2-硬件对并发的支持
			- 1-比较并交换
			- 2-非阻塞的计数器
			- 3-JVM对CAS的支持
		- 3-原子变量类
			- 1-原子变量是一种“更好的volatile”
			- 2-性能比较：锁与原子变量
		- 4-非阻塞算法
			- 1-非阻塞的栈
			- 2-非阻塞的链表
			- 3-原子的域更新器
			- 4-ABA问题
	- 16-Java内存模型
		- 1-什么是内存模型，为什么需要它
			- 1-平台的内存模型
			- 2-重排序
			- 3-Java内存模型简介
			- 4-借助同步
		- 2-发布
			- 1-不安全的发布
			- 2-安全的发布
			- 3-安全初始化模式
			- 4-双重检查加锁
		- 3-初始化过程中的安全性
- 1-简介
	- 1-并发简史
	- 2-线程的优势
		- 1-发挥多处理器的强大能力
		- 2-建模的简单些
		- 3-异步事件的简化处理
		- 4-响应更灵敏的用户界面
	- 3-线程带来的风险
		- 1-安全性问题
		- 2-活跃性问题
		- 3-性能问题
	- 4-线程无处不在
- 1-基础知识
	- 2-线程安全性
		- 1-什么是线程安全性
		- 2-原子性
			- 1-竞态条件
			- 2-示例：延迟初始化中的竞态条件
			- 3-复合操作
		- 3-加锁机制
			- 1-内置锁
			- 2-重入
		- 4-用锁来保护状态
		- 5-活跃性与性能
	- 3-对象的共享
		- 1-可见性
			- 1-失效数据
			- 2-非原子的64位操作
			- 3-加锁与可见性
			- 4-Volatile变量
		- 2-发布与逸出
		- 3-线程封闭
			- 1-Ad-hoc线程封闭
			- 2-栈封闭
			- 3-ThreadLocal类
		- 4-不变性
			- 1-Final域
			- 2-示例：使用Volatile类型来发布不可变对象
		- 5-安全发布
			- 1-不正确的发布：正确的对象被破坏
			- 2-不可变对象与初始化安全性
			- 3-安全发布的常用模式
			- 4-事实不可变对象
			- 5-可变对象
			- 6-安全的共享对象
	- 4-对象的组合
		- 1-设计线程安全的类
			- 1-收集同步需求
			- 2-依赖状态的操作
			- 3-状态的所有权
		- 2-实例封闭
			- 1-Java监视器模式
			- 2-示例：车辆追踪
		- 3-线程安全性的委托
			- 1-示例：基于委托的车辆追踪器
			- 2-独立的状态变量
			- 3-当委托失效时
			- 4-发布底层的状态变量
			- 5-示例：发布准头盖的车辆追踪器
		- 4-在现有的线程安全类中添加功能
			- 1-客户端加锁机制
			- 2-组合
		- 5-将同步策略文档化
	- 5-基础构建模块
		- 1-同步容器类
			- 1-同步容器类的问题
			- 2-迭代器与ConcurrentModificationException
			- 3-隐藏迭代器
		- 2-并发容器
			- 1-ConcurrentHashMap
			- 2-额外的原子Map操作
			- 3-CpoyOnWriteArrayList
		- 3-阻塞队列和生产者-消费者模式
			- 1-示例：桌面搜索
			- 2-串行线程封闭
			- 3-双端队列与工作密取
		- 4-阻塞方法与中断方法
		- 5-同步工具类
			- 1-闭锁
			- 2-FutureTask
			- 3-信号量
			- 4-栅栏
		- 6-构建高效且可伸缩的结果缓存
- 2-结构化并发应用程序
	- 6-任务执行
		- 1-在线程中执行任务
			- 1-串行地执行任务
			- 2-显式地位任务创建线程
			- 3-无限制创建线程的不足
		- 2-Executor框架
			- 1-示例：基于Executor的Web服务器
			- 2-执行策略
			- 3-线程池
			- 4-Executor的生命周期
			- 5-延迟任务与周期任务
		- 3-找出可利用的并行性
			- 1-示例：串行的页面渲染器
			- 2-携带结果的任务Callable与Future
			- 3-示例：使用Future实现页面渲染器
			- 4-在异构任务并行化中存在的局限
			- 5-CompletionService：Executor与BlockingQueue
			- 6-示例：使用CompletionService实现页面渲染器
			- 7-为任务设置时限
			- 8-示例：旅行预订门户网站
	- 7-取消与关闭
		- 1-任务取消
			- 1-中断
			- 2-中断策略
			- 3-响应中断
			- 4-示例：计时运行
			- 5-通过Future来实现取消
			- 6-处理不可中断的阻塞
			- 7-采用newTaskFor来封装非标准的取消
		- 2-停止基于线程的服务
			- 1-示例：日志服务
			- 2-关闭ExecutorService
			- 3-“毒丸”对象
			- 4-示例：只执行一次的服务
			- 5-shutdownNow的局限性
		- 3-处理非正常的线程终止
		- 4-JVM关闭
			- 1-关闭钩子
			- 2-守护线程
			- 3-终结器
	- 8-线程池的使用
		- 1-在任务与执行策略之间的隐形耦合
			- 1-线程饿死死锁
			- 2-运行时间较长的任务
		- 2-设置线程池的大小
		- 3-配置ThreadPoolExecutor
			- 1-线程的创建与销毁
			- 2-管理队列任务
			- 3-饱和策略
			- 4-线程工厂
			- 5-在调用构造函数后再定制ThreadPoolExecutor
			- 6-拓展ThreadPoolExecutor
			- 7-递归算法并行化
	- 9-图形用户界面应用程序
		- 1-为什么GUI是单线程的
			- 1-串行任务处理
			- 2-Swing中的线程封闭机制
		- 2-短时间的GUI任务
		- 3-长时间的GUI任务
			- 1-取消
			- 2-进度标识和完成标识
			- 3-SwingWorker
		- 4-共享数据模型
			- 1-线程安全的数据模型
			- 2-分解数据模型
		- 5-其它形式的单线程子系统
- 3-活跃性、性能与测试
	- 10-避免活跃性危险
		- 1-死锁
			- 1-锁顺序死锁
			- 2-动态的锁顺序死锁
			- 3-在协作对象之间发生的死锁
			- 4-开放调用
			- 5-资源死锁
		- 2-死锁的避免与诊断
			- 1-支持定时的锁
			- 2-通过线程转储信息来分析死锁
		- 3-其它活跃性危险
			- 1-饥饿
			- 2-糟糕的响应性
			- 3-活锁
	- 11-性能与可伸缩性
		- 1-对性能的思考
			- 1-性能与可伸缩性
			- 2-评估各种性能权衡因素
		- 2-Amdahl定律
			- 1-示例：在各种框架中隐藏的串行部分
			- 2-Amdahl定律的应用
		- 3-线程引入的开销
			- 1-上下文切换
			- 2-内存同步
			- 3-阻塞
		- 4-减少锁的竞争
			- 1-缩小锁的范围（“快进快出”）
			- 2-减小锁的粒度
			- 3-锁分段
			- 4-避免热点域
			- 5-一些替代独占锁的方法
			- 6-监测CPU的利用率
			- 7-向对象池说“不”
		- 5-示例：比较Map的性能
		- 6-减少上下文切换的开销
	- 12-并发程序的测试
		- 1-正确性测试
			- 1-基本的单元测试
			- 2-对阻塞操作的测试
			- 3-安全性测试
			- 4-资源管理的测试
			- 5-使用回调
			- 6-产生更多的交替操作
		- 2-性能测试
			- 1-在PutTaskTest中增加计时功能
			- 2-多种算法的比较
			- 3-响应性衡量
		- 3-避免性能测试的陷阱
			- 1-垃圾回收
			- 2-动态编译
			- 3-对代码路径的不真实采样
			- 4-不真实的竞争程度
			- 5-无用代码的消除
		- 4-其他的测试方法
			- 1-代码审查
			- 2-静态分析工具
			- 3-面向方面的测试技术
			- 4-分析与监测工具
- 4-高级主题
	- 13-显式锁
		- 1-Lock与ReentrantLock
			- 1-轮询锁与定时锁
			- 2-可中断的锁获取操作
			- 3-非块结构的加锁
		- 2-性能考虑因素
		- 3-公平性
		- 4-在synchronized与ReentrantLock之间进行选择
		- 5-读-写锁
	- 14-构建自定义的同步工具
		- 1-状态依赖性的管理
			- 1-示例：将前提条件的失败传递给调用者
			- 2-示例：通过轮询与休眠来实现简单的阻塞
			- 3-条件队列
		- 2-使用条件队列
			- 1-条件谓词
			- 2-过早唤醒
			- 3-丢失的信号
			- 4-通知
			- 5-示例：阀门类
			- 6-子类的安全问题
			- 7-封装条件队列
			- 8-入口协议与出口协议
		- 3-显式的Condition对象
		- 4-Synchronizer剖析
		- 5-AbstractQueueSynchronizer
		- 6-java.util.concurrent同步容器类中的AQS
			- 1-Reentrantlock
			- 2-Semaphore与CountDownLatch
			- 3-FutureTask
			- 4-ReentrantReadWriteLock
	- 15-原子变量与非阻塞同步机制
		- 1-锁的劣势
		- 2-硬件对并发的支持
			- 1-比较并交换
			- 2-非阻塞的计数器
			- 3-JVM对CAS的支持
		- 3-原子变量类
			- 1-原子变量是一种“更好的volatile”
			- 2-性能比较：锁与原子变量
		- 4-非阻塞算法
			- 1-非阻塞的栈
			- 2-非阻塞的链表
			- 3-原子的域更新器
			- 4-ABA问题
	- 16-Java内存模型
		- 1-什么是内存模型，为什么需要它
			- 1-平台的内存模型
			- 2-重排序
			- 3-Java内存模型简介
			- 4-借助同步
		- 2-发布
			- 1-不安全的发布
			- 2-安全的发布
			- 3-安全初始化模式
			- 4-双重检查加锁
		- 3-初始化过程中的安全性