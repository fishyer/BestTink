- 其它笔记
	- 项目经历，至少准备两个，因为至少有两轮技术面试
- 面试题库
	- 1-自我介绍
		- [[面试自我介绍]]
	- 2-你为什么离职
		- [[面试-离职原因]]
	- 3-你对加班的看法
		- 我觉得加班有两种
			- 第一种是那种临近上线时，偶尔有些突发事项，需要突击赶一下，我觉得这种偶尔的加班是可以接受的；
			- 但是对于第二种，平时上班时有什么事不早提出来，下班后才来找你的，我们应该尽量减少这种无谓的加班，提高自己的工作效率。
	- 4-你的期望薪资
		- [[面试-期望薪资]]
	- 5-你有什么想问我的么
		- [[面试-你有什么想问我的么]]
	- 6-你对面向对象的理解
	  collapsed:: true
		- 面向对象核心理念就是：抽象。主要是为了解决软件可拓展性、可维护性的问题。主要有3个特性：封装、继承、多态。
		- 把具体事物的属性和方法放到一个类里面，这就是封装，主要是为了保护隐私和隔离复杂度；
		- 继承类似生物学上的遗传，子类可以复用父类的属性和方法；
		- 多态指的是指向父类的引用，能够调用子类的对象，这也是我们面向接口编程的基础。
	- 7-接口和抽象类的区别
	  collapsed:: true
		- 抽象类和接口有类似之处：都不能用于创建对象，接口中的方法其实都是抽象方法。但是抽象类和接口的用途不一样，一般我们用接口声明能力，用抽象类提供默认实现，实现全部或部分方法。一个接口经常有一个对应的抽象类，比如Java类库中的List接口和对应的AbstractList抽象类。
	- 8-内部类的作用
	  collapsed:: true
		- 其实对JVM而已，它并不知道内部类，每个内部类最后都被编译为一个独立的类。根据定义的位置和方式不同，主要有4种内部类
		- 静态内部类：可以对类的职能做进一步的拆分，比如Integer类内部有IntegerCache，用于支持整数的自动装箱
		- 成员内部类：这个会自动持有外部类的实例的引用，使用时要注意，防止出现内存泄露问题
		- 方法内部列：这个用的较少，一般可以用成员内部类替代
		- 匿名内部类：一般用于接口回调
	- 9-请简述Java集合框架
	  collapsed:: true
		- Java集合框架为我们提供了大量数据结构的实现类和操作它们的算法，主要有List、Set、Map这三类。
	- 10-请简述Java IO框架
	  collapsed:: true
		- 主要有两类：处理二进制文件的字节流、处理文本文件的字符流
	- 11-请简述Java 并发框架
	  collapsed:: true
		- 1-线程和进程的区别
		- 线程是程序在执行过程中，能够执行代码的基本单位，线程有自己独立的堆栈和局部变量
		- 进程是系统进行资源分配和调度的基本单位，进程有自己独立的地址空间
	- 2-如何实现Java 多线程
	  collapsed:: true
		- 主要有3种方法
			- 1.继承Thread类，重写run()方法
			- 2.实现Runnable接口，实现run()方法
			- 3.实现Callable接口，实现run()方法
			- 3-线程的几种状态
		- 主要有5种状态
	- 12-请简述Java 内存模型
	  collapsed:: true
		- JMM是JVM中的一种规范，主要是为了屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。JMM决定一个线程对共享变量的写入何时对另一个线程可见。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
		- volatile的作用？
		- 保证内存可见性：一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程的本地内存中。
		- 防止重排序：
		- 事务的机制通常被概括为“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。
		- 原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。
		- 稳定性：数据库在事务执行前后状态都必须是稳定的。
		- 隔离性：事务之间不会相互影响。
		- 持久性：事务执行成功后必须全部写入磁盘。
		- 事务的机制通常被概括为“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。
		- 原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。
		- 稳定性：数据库在事务执行前后状态都必须是稳定的。
		- 隔离性：事务之间不会相互影响。
		- 持久性：事务执行成功后必须全部写入磁盘。
	- 13-谈谈你对设计模式的理解
	  collapsed:: true
		- 设计模式是核心就是：首先找到变化，然后封装变化。
		- 有两个基本思想就是：
		- 基于接口编程，而不是基于实现编程
		- 优先使用对象组合，而不是类继承
		- 设计原则主要用于指导类的定义的设计，设计模式主要用于指导类的行为的设计
		- 常用的设计模式
		- 单例
		- 工厂方法
		- 建造者
		- 观察者
		- 策略
	- 14-请简述Java垃圾回收机制
	  collapsed:: true
		- JVM中是使用的分代收集算法。
		- 首先新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。
		- 当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。
		- 永久代主要用于存放静态文件，如Java类、方法等。
	- 15-请简述Java类加载机制
	  collapsed:: true
		- 类加载过程
		- 加载：生成Class对象
		- 验证：确保Class字节流符合虚拟机要求
		- 准备：正式为类变量分配内存并设置类变量的初始值
		- 解析：虚拟机将常量池中的符号引用替换为直接引用
		- 初始化：除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码
		- 双亲委派模型
		- 启动类加载器（Bootstrap ClassLoader）：负责加载&lt;JAVA_HOME&gt;\lib目录下或者被-Xbootclasspath参数所指定的路径的，并且是被虚拟机所识别的库到内存中
		- 扩展类加载器（Extension ClassLoader）：负责加载&lt;JAVA_HOME&gt;\lib\ext目录下或者被java.ext.dirs系统变量所指定的路径的所有类库到内存中
		- 应用类加载器（Application ClassLoader）：负责加载用户类路径上的指定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载器去加载应用程序中的类库
		- 双亲委派模型的整个工作流程：如果一个类加载器收到了加载类的请求，它不会自己立即去加载类，它会先去请求父类加载器，每个层次的类加载器都是如此。层层传递，直到传递到最高层的类加载器，只有当父类加载器反馈自己无法加载这个类，才会有当前子类加载器去加载该类。
		- Android类加载器的基类是BaseDexClassLoader，它有派生出两个子类加载器：
		- PathClassLoader: 用于系统和app的类加载器，只能加载已经安装到Android系统中的APK文件
		- DexClassLoader: 支持加载外部的APK、jar或者dex文件，通常用它实现插件化
	- 16-请简述Java 中注解的应用
	  collapsed:: true
		- 注解为我们在代码中添加了额外信息，使我们可以在稍后的某个时刻去处理这些信息
		- 可以在编译时用apt来处理：继承AbstractProcessor，重写process方法，可以借助javaPoet代码处理工具
		- 可以在运行时用反射来处理
	- 17-请简述Java 动态代理的应用
	  collapsed:: true
		- 所谓动态代理，给某个对象提供一个代理对象，让客户通过代理对象间接地操控原对象。基础AOP思想就是基于动态代理的的拓展
		- Java实现动态代理的大致步骤如下
		- 1.定义一个委托类和公共接口
		- 2.自己定义一个类实现 InvocationHandler接口，在运行时生成代理类来完成具体任务
		- 3.生成代理对象，需要为他指定：委托对象、实现的一系列接口、调用处理器类的实例
	- 18-谈谈你对死锁的理解
	  collapsed:: true
		- 原因：在任何地方都可能线程切换，甚至在一条语句中间，而很多操作都不具备原子性
		- 造成死锁必须达成的4个条件（原因）：
		- 互斥条件：一个资源每次只能被一个线程使用。【要有锁】
		- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。【拿了锁，再去拿另一个锁】解决方案：一次性获取所有锁，但大多编程语言无法实现
		- 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。【互相等待，A等待B，B等待A】解决方案：加上顺序，可以利用id排序
		- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。【无法剥夺，A、B都不会自动取消锁】解决方案：加上超时
	- 19-谈谈你对显式锁的理解
	  collapsed:: true
		- 显式锁接口是Lock，主要实现是ReentrantLock，相比synchronized，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时。
	- 20-谈谈常用的Java并发工具类
	  collapsed:: true
		- 读写锁：ReentrantReadWriteLock
		- 信号量：Semaphore
		- 倒计时门栓：CountDownLatch
		- 循环栅栏：CyclicBarrier
	- 21-数据库事务的原理
	  collapsed:: true
		- 事务的机制通常被概括为“ACID”原则即原子性（A）、稳定性（C）、隔离性（I）和持久性（D）。
		- 原子性：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。
		- 稳定性：数据库在事务执行前后状态都必须是稳定的。
		- 隔离性：事务之间不会相互影响。
		- 持久性：事务执行成功后必须全部写入磁盘。
		- 在传统的架构中，对于客户端的每一次请求，服务器都会创建一个新的线程或者利用线程池复用去处理用户的一个请求，然后返回给用户结果，这样做在高并发的情况下会存在非常严重的性能问题：对于用户的每一次请求都创建一个新的线程是需要一定内存的，同时线程之间频繁的上下文切换也是一个很大的开销。在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。
	- 22-请简述Java NIO
	  collapsed:: true
		- 普通IO的问题：在传统的架构中，对于客户端的每一次请求，服务器都会创建一个新的线程或者利用线程池复用去处理用户的一个请求，然后返回给用户结果，这样做在高并发的情况下会存在非常严重的性能问题：对于用户的每一次请求都创建一个新的线程是需要一定内存的，同时线程之间频繁的上下文切换也是一个很大的开销。
		- NIO的核心就是Selector，现在对于客户端的每一次请求到来时我们不再立即创建一个线程进行处理，相反（以epool为例子）当一个事件准备就绪之后通过回调机制将描述符加入到阻塞队列中，下面只需要通过遍历阻塞队列对相应的事件进行处理就行了，通过这种回调机制整个过程都不需要对于每一个请求都去创建一个线程去单独处理。
		- NIO是单线程非阻塞的，基于通知来实现。
	- 23-请简述Handler机制
	  collapsed:: true
		- Handler的工作流程
		- HandlerThread
		- IntentService
		- AsyncTask
	- 24-请简述Binder机制
	  collapsed:: true
		- Binder的工作流程
		- Android进程间通信方式
	- 25-请简述View绘制流程
	  collapsed:: true
		- View绘制流程
		- View的坐标系
	- 26-请简述事件分发流程
	  collapsed:: true
		- 简单的事件分发
		- 嵌套滑动事件
		- CoordinatorLayout+ Behavior的流程
	- 27-Android 5.0、6.0、7.0新特性
	  collapsed:: true
		- Android 4.x
		- 1.新锁屏界面
		- 2.全新Widget排列
		- 3.更直观的程序文件夹
		- 4.人脸识别解锁
		- 5.截屏功能
		- 6.全新通知栏
		- 7.语音识别的键盘
		- 8.浏览器
		- Android 5.x
		- 1.Material design
		- 2.改善通知栏
		- 3.系统由以往的Dalvik模式改为采用ART（Android Runtime）模式
		- 4.V7中引入CardView和RecycleView等新控件
		- 5.支持64位系统
		- Android 6.x
		- 1.新增运行时权限概念
		- 2.新增瞌睡模式和待机模式
		- 3.移除对Apache HTTP client的支持
		- 4.Doze电量管理
		- Android 7.x
		- 1.通知栏快捷回复
		- 2.加入原生分屏多任务功能
		- 3.VR
		- 4.引入全新的JIT编译器
		- 5.安全：更安全的加密模式
		- Android O（8.0）
		- 1.画中画
		- 2.Notification Dots
		- 3.自动填充（Auto-Fill）
		- 4.自适应图标（Adaptive icons）
		- 5.后台进程限制
		- 6.运行时权限策略变化
		- Android P（9.0）
		- 1.使用 WiFi RTT 进行室内定位
		- 2.凹口屏幕的支持
		- 3.消息通知的改进
		- 4.多摄像头 API
		- 5.用于位图和 drawable 的 ImageDecoder
		- 6.HDR VP9 视频、HEIF 以及媒体 APIs
		- 7.JobScheduler 中的数据费用敏感度
		- 8.神经网络 API 1.1
		- 9.自动填充的改进
		- 10.用于 NFC 支付和安全交易的 Open Mobile API
	- 28-Android数据存储的几种方式
	  collapsed:: true
		- 1.使用SharedPreferences存储数据
		- 2.文件存储数据
		- 3.SQLite数据库存储数据
		- 4.使用ContentProvider存储数据
		- 5.网络存储数据
	- 29-请简述Activity
	  collapsed:: true
		- Activity的生命周期
		- Activity的启动模式
		- standard
		- singleTop
		- singleTask
		- singleInstance
		- IntentFilter
	- 30-请简述Service
	  collapsed:: true
		- Service的生命周期
	- 31-请简述BroadcastReceiver
	  collapsed:: true
		- 静态注册与动态注册
		- 普通广播与有序广播
		- 本地广播和全局广播
		- 粘性广播
		- 广播和EventBus
	- 32-请简述ContentProvider
	- 33-请简述Fragment
	  collapsed:: true
		- Fragment的生命周期
	- 34-请简述WebView
	- 35-请简述SurfaceView
	- 36-序列化的几种方式
	- 38-Http协议
	- 39-Socket
	- 40-Https安全机制
	- 41-OAuth2认证机制
	- 42-TCP与UDP的区别
	- 43-请简述一个网页从请求到显示的整个流程
	- 44-AsyncTask的实现原理
	- 45-Volley的源码分析
	- 46-谈谈你对MVP的理解
	  collapsed:: true
		- 演变图
		- MVC
		- M层：这里的model不是说实体类， 他是主要实现逻辑的地方；
		- V层：放置视图相关的代码，原则上里面不应该有任何业务逻辑；
		- C层：放置视图与模型之间的映射，原则上这里应该很薄，他只放一些事件绑定相关的代码(router)，但并不实现真正的功能，他只是一个桥梁。
		- 缺点：这里呢，View 和 Model 并不是完全脱离的，还是有一些逻辑耦合，因为需要根据修改后的Model重新刷新View。比如Model加载完网络数据后，怎么让View展示这些数据呢？
		- MVP
		- V层一般会实现一个接口，方便P层抽象依赖。
		- P层： 通过调用 View 的接口来实现对视图的操作，这个 View 接口的东西一般来说是 showData、showLoading等等。
		- 缺点：M与V已经隔离了，方便测试了，但新的问题又来了：P层太重。当M改变时，M通知P去改变V， 所以V变得更纯洁(刷新逻辑被移动到了P层)， 为了保证M可以最大程度的复用,一部分业务逻辑也从M转移到了P，所以，MVP下P有时显得有点重。
		- MVVM
		- 在 MVVM 中就出现了双向绑定这个概念，意思就是View 接口的 showData 这些实现方法可以不写了。而所谓的双向绑定呢，其中有一种实现方式就是双向的观察者模式，V和M都同时既是观察者也是被观察者，换个通俗的说法就是：M改变后会触发回调更新V，而V改动后也会触发回调更新M。但是呢，如果每次都需要手动实现双向的观察者模式，那就未免太麻烦了，这就需要VM层了。
		- VM层：ViewModel充当了一个数据转换器的作用。它依赖特定的框架，自动帮我们将Model信息转换为View信息，还将命令从View传递到Model。
		- 缺点：数据绑定的声明是指令式地写在View的模版当中，和传统习惯不一样，有一定的学习成本，同时，这些内容是没办法去打断点debug的。
	- 47-网络劫持的原理
	- 48-OkHttp的源码分析
	  collapsed:: true
		- OkHttp流程图
		- OkHttp的拦截机制
	- 49-Retrofit的源码分析
	- 50-RxJava的源码分析
	- 51-App启动流程
	- 52-XML解析方式
	- 53-数据库导入与升级
	- 54-【】
	- 55-Activity、Window、View三者的区别
	  collapsed:: true
		- Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图） LayoutInflater像剪刀，Xml配置像窗花图纸。
		- 1. 在Activity中调用attach，创建了一个Window
		- 2. 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow
		- 3. 在Activity中调用setContentView([R.layout.xxx](http://R.layout.xxx))
		- 4. 其中实际上是调用的getWindow().setContentView()
		- 5. 调用PhoneWindow中的setContentView方法
		- 6. 创建ParentView： 作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类）
		- 7. 将指定的R.layout.xxx进行填充 通过布局填充器进行填充【其中的parent指的就是DecorView】
		- 8. 调用到ViewGroup
		- 9. 调用ViewGroup的removeAllView()，先将所有的view移除掉
		- 10. 添加新的view：addView()
	- 56-请简述OOM
	- 57-请简述ANR
	- 58-如何实现后台保活
	- 59-请简述推送原理
	- 60-请简述Android中的动画框架
	- 61-View优化怎么做
	- 62-网络优化怎么做
	- 63-内存优化怎么做
	  collapsed:: true
		- 内存泄露
	- 64-什么是AOP
	  collapsed:: true
		- 面向切面编程（Aspect-Oriented Programming）,是对面向对象开发的一种补充。
		- 它允许开发人员在不改变原来模型的基础上动态的修改模型以满足新的需求，例如，开发人员可以在原来业务逻辑的基础上动态地增加日志、安全、异常处理等功能，可以认为是动态代理模式的一种拓展。
		- 在Android中的应用，主要就是AspectJ。
	- 65-什么是IOC
	  collapsed:: true
		- 控制反转（Inverse of Control）,有时也被称为依赖注入，是一种降低对象之间耦合关系的设计思想。
		- 一般来说，会有一个容器来统一管理控制对象的创建，可以认为是工厂模式的拓展。
		- 当需要一个对象时，不需要在客户端手动创建，这样，后期就算被依赖的对象的构造方法有了修改，也无需改动客户端。
		- 在Android中的应用，主要就是ButterKnife和Dragger2。
	- 66-什么是ORM
	  collapsed:: true
		- 所谓ORM，即**对象-关系映射** （Object/Relation Mapping），方便我们以操作对象的方式去操作关系型数据库。
		- 在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL 语句与解析查询结果等。
		- 但是有时候一不小心sql拼错了，或者cursor取字段时字段名写错了，就导致程序异常！
		- 于是，各种ORM框架就出来了，将生成建表sql、解析cursor成对象，都自动化了，可以有效降低我们出错的概率
	- 67-重构的方法
	- 68-直播的原理
	- 69-如何自定义下拉刷新
	- 70-apk体积优化怎么做
	- 71-如何自定义控件
	- 72-Glide的源码分析
	- 73-Picasso的源码分析
	- 74-UIL的源码分析
	- 75-Dragger2的源码分析
	- 76-ButterKnife的源码分析
	- 77-RecyclerView和ListView的区别
	- 82-常见的字符编码，如何解决乱码
	- 84-如何实现观察者模式
	- 85-AIDL的使用流程
	- 86-布局优化怎么做
	- 87-请简述Java的4种引用
	- 88-JNI的使用流程
	- 89-请简述REST
	- 90-屏幕适配怎么做
	- 91-数字签名有什么用，请简述Android的安全机制
	- 92-请简述代码混淆和加固
	- 93-多渠道打包怎么做